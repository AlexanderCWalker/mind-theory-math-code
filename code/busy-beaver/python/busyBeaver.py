#moving right
def move_right(turing_tape, tape_position):

    #increasing position along the tape by 1
    tape_position += 1

    #if that position is out of range, add a position
    if tape_position == len(turing_tape):
        turing_tape.append(0) #adds 0 to the end of the list

    return turing_tape, tape_position

#moving left
def move_left(turing_tape, tape_position):

    #decreasing position along the tape by 1
    tape_position -= 1

    #if that position is out of bounds on the left, add a position to the left side
    if tape_position <0:
        turing_tape.insert(0,0) #adds 0 to the front of the list
        tape_position +=1 #maintaining correct tape position; adjusting position to account for added spot

    return turing_tape, tape_position

#applying rules
def apply_rule(turing_tape, tape_position, turing_state, rule):
    #changing turing state
    turing_state = rule[0]
    #marking the turing tape
    turing_tape[tape_position] = int(rule[1])
    if rule[2] == 'r':
        turing_tape, tape_position = move_right(turing_tape, tape_position)
    #moving turing tape
    elif rule[2] == 'l':
        turing_tape, tape_position = move_left(turing_tape, tape_position)

    return turing_tape, tape_position, turing_state

#initialize turing machine - apply rules until halt using a while loop - this will repeat something until the program terminates or is satisfied

#initialize
def run_turing(rule_set,readout = True):
    turing_tape = [0] #defining the tape as a list starting at position 0
    tape_position = 0 # initial position
    turing_state = 'a' #initial state
    halt_state = 'h' #state at which the program will halt

    #rules will be applied until we reach the halt state
    while turing_state != halt_state:

        if readout:

            print('State: {}, Tape: {}'.format(turing_state,turing_tape))

        #retrieve rule - where are we and what is the corresponding rule in our dictionary
        rule_key = '{}{}'.format(turing_state, turing_tape[tape_position]) #what is the current rule for that rule key/state
        current_rule = rule_set[rule_key]

         #applying rule
        turing_tape, tape_position, turing_state = apply_rule(turing_tape, tape_position, turing_state, current_rule)

    if readout:
        print('State: halt, Tape: {}'.format(turing_tape))

    #Calculate number of 1's generated by "busy beaver"
    N1 = sum(turing_tape)
    print('This set of rules produced {} data points'.format(N1))

#Define optimal beaver rules for 2 state
beaver_rules2 =    {'a0': 'b1r', 'a1': 'b1l',
                    'b0': 'a1l', 'b1': 'h1r'}
#Define beaver rules for 5 state
beaver_rules5 =    {'a0': 'b1r', 'a1': 'b1l',
                    'b0': 'a1l', 'b1': 'c1r',
                    'c0': 'd1r', 'c1': 'b1r',
                    'd0': 'e1l', 'd1': 'e1r',
                    'e0': 'd1r', 'e1': 'h1r'}

#Choose your states:
state = input("choose your n-state {2 or 5}: ")
if state == '2':
    states = beaver_rules2
elif state == '5':
    states = beaver_rules5

run_turing(states,readout = True)
