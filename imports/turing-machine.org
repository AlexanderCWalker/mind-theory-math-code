#+Title: Turing Machines

* Overview

* Readings

** The Busy Beaver

   Use your programming language to write a Busy Beaver Turing Machine. If you have already done this in the past please refrain from helping your team too much, and if you don't know what it is, don't do an internet search for the time-being.

   The following is the Wikipedia description:
   #+begin_quote

   The machine has n "operational" states plus a Halt state, where n is a positive integer, and one of the n states is distinguished as the starting state. (Typically, the states are labelled by 1, 2, ..., n, with state 1 as the starting state, or by A, B, C, ..., with state A as the starting state.)
The machine uses a single two-way infinite (or unbounded) tape.
The tape alphabet is {0, 1}, with 0 serving as the blank symbol.
The machine's transition function takes two inputs:

    the current non-Halt state,
    the symbol in the current tape cell,

and produces three outputs:

    a symbol to write over the symbol in the current tape cell (it may be the same symbol as the symbol overwritten),
    a direction to move (left or right; that is, shift to the tape cell one place to the left or right of the current cell), and
    a state to transition into (which may be the Halt state).

   There are thus (4n + 4)2n n-state Turing machines meeting this definition because the general form of the formula is (symbols × directions × (states + 1))(symbols × states).
The transition function may be seen as a finite table of 5-tuples, each of the form
    (current state, current symbol, symbol to write, direction of shift, next state).

    "Running" the machine consists of starting in the starting state, with the current tape cell being any cell of a blank (all-0) tape, and then iterating the transition function until the Halt state is entered (if ever). If, and only if, the machine eventually halts, then the number of 1s finally remaining on the tape is called the machine's score.

The n-state busy beaver (BB-n) game is a contest to find such an n-state Turing machine having the largest possible score — the largest number of 1s on its tape after halting. A machine that attains the largest possible score among all n-state Turing machines is called an n-state busy beaver, and a machine whose score is merely the highest so far attained (perhaps not the largest possible) is called a champion n-state machine.
   #+end_quote


* Exercises

1. Busy Beaver Warm-up

Here are the rules for n=2. Create this Turing Machine using your group's programming language.

a0 -> b1r
a1 -> b1l
b0 -> a1l
b1 -> h1r


Need to load trivia

#+begin_src lisp :results silent :exports code
  (defstruct turing-machine state tape head-location)  
#+end_src

#+begin_src lisp :exports code :results silent
  (defun move-left (tm)
    (let ((loc (turing-machine-head-location tm))
	  (lst (turing-machine-tape tm)))
      (if (= loc 0)
	  (setf (turing-machine-tape tm) (cons 0 lst))
	  (setf (turing-machine-head-location tm) (- loc 1)))))
  (defun move-right (tm)
    (let ((loc (turing-machine-head-location tm))
	  (lst (turing-machine-tape tm)))
      (when (= (+ loc 1) (length lst))
	(setf (turing-machine-tape tm) (append lst (list 0))))
      (setf (turing-machine-head-location tm) (+ loc 1))))
  
  (defun move (tm dir)
    (cond 
      ((eq dir 'left)
       (move-left tm))
      ((eq dir 'right)
       (move-right tm))))
#+end_src

#+begin_src lisp :results silent :exports code
  (defun equal-sv (tm s v)
    (and (eql (turing-machine-state tm) s)
	 (= (elt (turing-machine-tape tm) (turing-machine-head-location tm)) v)))
  
  (defun rule (tm) ;;state value
    (cond
      ((equal-sv tm 'a 0)
       (setf (turing-machine-state tm) 'b)
       (setf (elt (turing-machine-tape tm) (turing-machine-head-location tm)) 1)
       (move tm 'right))
      ((equal-sv tm 'a 1)
       (setf (turing-machine-state tm) 'b)
       (setf (elt (turing-machine-tape tm) (turing-machine-head-location tm)) 1)
       (move tm 'left))
      ((equal-sv tm 'b 0)
       (setf (turing-machine-state tm) 'a)
       (setf (elt (turing-machine-tape tm) (turing-machine-head-location tm)) 1)
       (move tm 'left))
      ((equal-sv tm 'b 1)
       (setf (turing-machine-state tm) 'h)
       (setf (elt (turing-machine-tape tm) (turing-machine-head-location tm)) 1)
       (move tm 'right))))
#+end_src

#+begin_src lisp :results silent :exports both
  (defparameter *initial-state* (make-turing-machine :state 'a :tape (list 0) :head-location 0))
  (defun pp-tm (tm)
    (format t "~&state:~a, tape: ~a, head: ~a" (turing-machine-state tm) (turing-machine-tape tm) (turing-machine-head-location tm)))
  
  (defun bb (tm)
   (progn
     (pp-tm tm)
     (do ()
      ((eql (turing-machine-state tm) 'h))
       (rule tm)
       (pp-tm tm))))
    #+end_src

#+begin_src lisp :results output :exports both
  (bb *initial-state*)
#+end_src

#+RESULTS:
: state:A, tape: (0), head: 0
: state:B, tape: (1 0), head: 1
: state:A, tape: (1 1), head: 0
: state:B, tape: (0 1 1), head: 0
: state:A, tape: (0 1 1 1), head: 0
: state:B, tape: (1 1 1 1), head: 1
: state:H, tape: (1 1 1 1), head: 2




2. Busy Beaver Competition

Try to come up with a version for n=5 and we will run them against each other in class. The current chanmpion produces 4098 ones over about 50 million steps. 

